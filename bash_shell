
## 简单的转义符
转义符 | 含义
---|---
\n | 表示新的一行
\r | 表示回车
\t | 表示水平制表符
\v | 表示垂直制表符
\b | 表示后退符
\a | 蜂鸣或者闪烁
\0xx | 转换为八进制的ASCII码, 等价于0xx


## 关于/dev/null /dev/zero
- /dev/null  ： 在类Unix系统中，/dev/null，或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。

- /dev/zero  ： 当你读它的时候，它会提供无限的空字符(NULL, ASCII NUL, 0x00)。其中的一个典型用法是用它提供的字符流来覆盖信息，另一个常见用法是产生一个特定大小的空白文件。


## 规范
"$UID"  当前执行用户
"$1" 表示第一个参数
```
if [ `pwd` != "$LOG_DIR" ] # 也可以这样写 if [ "$PWD" != "$LOG_DI
R" ]
通过命令pwd检查当前路径
```
```
if [ 条件 ]
then
else
fi
```


### 关于注释
```
#!/bin/sh  调用系统默认shell,linux默认为bash
#!/bin/bash
#!/usr/bin/perl
#!/usr/bin/tcl
#!/bin/sed -f
#!/bin/awk -f
```


### 关于错误
"Command not found"
查看`#!`后的路径是否正确


开头注释sh,相当于命令sh filename [参数]
如果开头使用`#!/bin/rm`或`#!/bin/more`则形成删除或打印本身的脚本文件

### 脚本执行
编写一个脚本scriptname
- 通过`sh scriptname`执行
- 执行`chmod 555 scriptname`,然后通过`./scriptname`执行
- 将脚本移到`/usr/local/bin`下，使脚本被所有用户以命令形式执行。使用scriptname命令


### 关于特殊字符
- `#` 注释
- `;` 同一行执行多条命令
- `;;` case条件语句终止符
- `.` bash内置的等价于source的命令，更新操作。也作为隐藏文件名前缀。也作为当前目录。也在正则中用来匹配单个字符
- `"` 在字符串中保留大部分特殊字符
- `'` 在字符串中保留所有特殊字符,即禁用转义字符
- `,` 将一系列算术运算符串连起来
- `\` 转义
- `!` 取反
- `*` 通配符,使用[[ $value == z* ]]
- `$` 用来取变量的值。也匹配行结束符。
- `$?` 返回状态变量。此变量保存一个命令、一个函数或该脚本自身的返回状态。
- `$$` 进程ID变量
- `()` 通过执行括号中的命令组形成一个子shell进程，括号中的变量外部不能访问
- `{xxx,yyy,zzz,...}` 命令，文件扩展名等作用于大括号中的每个文件。除被引用或者被转义，否则不能有空白符。 {a..z} 表示a到z的所有字符
- `{}` 代码块，相当于一个内联函数，函数中变量在外部可见。代码块可以通过I/O重定向进行输入输出
- `$#` 参数数量
```
file = /home/lxd/filename
{
    read line1
    read line2
} < $file
```
也可作为文本占位符使用
- `[]` 测试语句可填。整数扩展符使用例子`echo $[$a+$b]`
- `\<, >` 正则中的单词边界 例`bash$ grep '\<the\>' textfile`
- `&&` 逻辑运算符
- `--` 双横线不懂
- `~+` 当前工作目录。它等同于内部变量 $PWD
- `~-` 先前的工作目录。它等同于内部变量 $OLDPWD

## 移动一个目录
```
tar参数：
c 创建一个新的档案
f - 指定文件，-后跟一个文件作为输出，默认重定向到标准输出
x 解压档案
p 保留档案内文件的所有权及权限
v 发送全部信息到标准输出

(cd /source/directory && tar cf - .) | (cd /dest/directory && tar xpvf -)
```

关于控制符的定义在P54

## 变量与参数
字符串内引用变量将会保留所有空白符

当变量被赋值(使用let赋值;在for中赋值;在read表达式中赋值)时，变量是非引用格式。

变量赋值时不要加多余的空格，错例：`a = 23`。应为：`a=23`
将命令结果赋值时，使用`符号来圈命令,不能是单引号或双引号
```
a = `ls -l`
echo $a
```

环境变量：会影响用户及shell行为的变量。导出环境变量用export命令

位置参数：即命令行传递给脚本的参数$1,$2,$3      通过`args=$#`获取参数的个数
使用前记得判断存在性`if [ -n "$1" ]`,`if [ -n "${11}" ]`  或 `if[ -z "$1" ]`检测参数是否被传入
如果不晓得参数个数，可以使用shift命令对参数列表进行for循环左移，左移时，$0不受影响，剩下依次左移。

引用变量时，通常建议包含在双引号中，这样可以防止除$,`,\,外的其他字符被重新解释


## 关于退出和退出状态
每个正常的UNIX命令退出都会产生退出码，一般成功时为0，失败是非0.

`$?`给出上一条执行命令的退出状态

## 关于测试
- `if/then`测试结构，课检测某一条命令的退出状态决定接下来要执行的命令,if后要加空格
- `[` 使用这个测试命令，该命令将参数视为比较表达式，以比较结果作为退出码
- `[[` 测试关键字
- `((`和`let`根据其执行的算术表达式的结果决定退出状态
- `((`比较特殊，返回值为0时，返回1，返回值不为0时，返回0

```
if test -z "$1"
同 if /usr/bin/test -z "$1"
同 if [ -z "$1" ]
同 if /usr/bin/[ -z "$1" ]
```

关于true/false:
随机的数值或者字符串为真
null值和未初始化的变量为假

关于文件测试参数：
- `-e` 检测文件是否存在
- `-f` 文件是常规文件，非目录，非设备
- `-s` 文件大小不为0
- `-d` 文件是一个目录
- `-b` 文件是一个块设备
- `-c` 文件是一个字符设备
- `-p` 文件是一个管道文件
- `-h` 文件是一个符号链接
- `-s` 文件是一个套接字
- `-t` 文件与终端设备相连
- `-r/w/x` 该文件对执行测试的用户可读/写/执行
- `f1 -nt/ot f2` 文件f1比f2新/旧
- `f1 -et f2` 文件f1和f2硬链接到同一个文件

关于整数比较参数：
- `-eq` 等于
- `-ne` 不等于
- `-gt`,`>` 大于
- `-ge`, `>=` 大于等于
- `-lt`,`<` 小于
- `-le`,`<=` 小于等于
bash不能处理浮点数，会直接将小数视为字符串

字符串比较参数：
`=`,`==`,`!=`,`>`,`<`等均可用，记得比较符号左右加空格。
- `-z` 字符串为空
- `-n` 字符串非空

复合比较：
- `-a` 逻辑与
- `-o` 逻辑或

关于运算符
- `=` 赋值，用于字符串或数字，左右不能有等号
- `**` 幂运算 `5**3即5*5*5`

## 关于字符串
bash提供很多操作字符串的函数。主要的有expr函数，其下有很多子函数
- ``expr match "string" 'ab[A-Z]'`` 返回匹配的个数
- ``${string#substring}`` 或 ``${string##substring}``删除从$string开始，匹配到最短/长的字符串
- ``${string/substring/replace}`` 或 ``${string/#substring/replace}`` 匹配第一个substring为replace
- ``${string/%substring/replace}``匹配string末端的substring
- ``${string//substring/replace}`` 匹配所有substring为replace


## 关于参数替换
`${parameter-default}` 或 `${parameter:-default}`这两个方式可以做参数替换，给还没有声明或赋值的变量输出
比如当传入参数的数量不足时，可以用这种缺省的方式：
`filename=${1:-$DEFAULT_FILENAME}`



## 关于循环
循环即遍历，使用结构：
```
for i in [list]
do
    echo ...
done
```
并且支持通配符

比如对当前目录下j开头的文件进行遍历操作:
```
//即可陈列j开头的文件详细信息

for file in j*
do
    ls -l "$file"
done
```

```
//condition不为真时循环停止
while [ condition ]
do
    command(s)
done
```
```
//condition为真时循环停止
while [ condition ]
do
    command(s)
done
```
简单的循环建议使用for,迭代执行命令建议使用while和until
break,continue用法同C，一个中止循环，一个略过后文进行下一次循环，continue后加整数可以决定影响上层的几层循环，缺省影响一层循环


记得循环避免使用：
```
cat "$FILE" | while read line;do
    echo " "
    done
```
在这种循环里操作全局变量不会改变值
使用：
```
while read line;do
    echo " "
done < ${FILE}
```

## 测试与分支
格式：
```
case "$variable" in
    "$condtition1" )
        command...
    ;;
    "$condtition1" )
        command...
    ;;
esac
```

错误：书中240页样例11-28最后一个函数测试应为：
```
match_string $b $d
    echo $?
```

## 关于select的使用
结构：
```
PS3="Choose:" //默认提示语变量赋值PS3
select $a in "one" "two" "three"
do
    echo $a
    break
done
```
运行后，会将one ,two, three 带着1，2，3前标陈列，出现提示语，用户选择某一项后，执行 `do...break` 内容并退出。如果没有break，无限提供选择

## 关于命令替换
命令替换即将命令的输出导出到另一个地方，可将执行作为变量赋值，作为函数参数，for循环列表等。以`号包裹，相当于当前SHELL的一个子进程。


## 关于内部变量
内建变量，将会影响bash脚本的行为
内建命令 | 含义
---|---
$PATH | 可执行文件搜索路径
$BASH bash | 二进制程序文件的路径
$BASH_VERSINFO | 包含6个bash版本信息
$BASH_VERSION | 系统安装的版本号
$DIRSTACK | 目录栈最顶端的值
$EDITOR | 脚本所调用的默认编辑器
$EUID | "有效"用户ID
$FUNCNAME | 当前函数的名字
$GROUPS | 目前用户所属的组
$HOME | 用户的home目录
$IFS | 内部域分隔符，用来解释字符串时如何分割域
$LINENO | 所在脚本的行号
$PIPESTATUS | 这个数组变量将保存最后一个运行的前台管道的退出状态码.
$PS1 | 这是主提示符, 可以在命令行中见到它.
$PS2 | 第二提示符, 当你需要额外输入的时候, 你就会看到它. 默认显示">".
$PS3 | 第三提示符, 在一个select循环中显示
$PS4 | 第四提示符, 当你使用-x选项来调用脚本时, 这个提示符会出现在每行输出的开头. 默认显示"+".
$SECONDS | 这个脚本已经运行的时间(以秒为单位).
$TMOUT | shell提示符显示时间，在脚本中与read配合限制等待输入时间
$UID | 用户ID号
$RANDOM | 内部函数，产生随机数

## 关于字符串
- 字符串长度
```
${#string}
expr length $string
expr "$string" : '.*'
```
- 匹配字符串开头的子串长度
```
expr match "$string" '$substring'
expr "$string" : '$substring'
```

- 提取子串
```
${str:pos} //pos开始到结尾的子串
${str:pos:len} //pos开始的len长度的子串
expr sub $str $pos $len //同上
${str#sub}
//从$str的开头位置截掉最短匹配的$sub
比如ab:12 要取key/val值，比如截掉前段：${str#*:}

${str##sub}
// 从$str的开头位置截掉最长匹配的$sub
${str%sub}
// 从$str的结尾位置截掉最短匹配的$sub
${str%%sub}
从$str的结尾位置截掉最长匹配的$sub
```
- 子串替换
```
${str/sub/rep}
//使用$rep来替换第一个匹配的$sub
${str//sub/rep}
//使用$rep来替换所有匹配的$sub
${str/#sub/rep}
//如果$sub匹配$str的开头部分, 那么就用$rep来替换$sub.
${str/%sub/rep}
//如果$sub匹配$str的结尾部分, 那么就用$rep来替换$sub
```

## 指定变量的类型
declare/typeset选项:
- `-r` 只读
- `-i` 整型
- `-a` 数组
- `-f` 函数
- `-e` 环境变量
- `-x` 声明变量同时为其赋值

## 变量的间接引用
如果一个变量的值，是另一个变量的名字，我们可以通过间接引用来获取第二个变量的值。
```
a=temp
temp=2

echo "Before:a = $a" // Before:a = temp
eval a=\$$a //间接引用
echo "After:a = $a" //After:a=2
```

## ((...))
bash中使用C语言风格操作的一种处理机制
例：
```
a=$((2+3))
((a++))
((a=3))
(( t = a<45?7:11 ))   # C语言风格的三元操作
```

## 作业控制命令
|命令 | 含义
---|---
jobs | 在后台列出所有正在运行的作业, 给出作业号
wait | 停止脚本的运行,直到后台运行的所有作业结束为止
disown | 从shell的激活作业表中删除作业.
fg, bg | fg把后台作业放到前台来 bg会重启一个挂起的作业, 并且在后台运行它
logout | 退出一个已经登陆上的shell,也可以指定一个退出状态码.
times | 给出执行命令所占用的时间,使用如下的形式进行输出
kill | 通过发送一个适当的结束信号, 来强制结束一个进程

 注意一下Bash执行命令的优先级:
- 1	别名
- 2	关键字
- 3	函数
- 4	内建命令
- 5	脚本或可执行程序($PATH)

作业标识符

|记法 |	含义
---|---
%N|	作业号[N]
%S|	以字符串S开头的被(命令行)调用的作业
%?S|	包含字符串S的被(命令行)调用的作业
%%|	"当前"作业(前台最后结束的作业, 或后台最后启动的作业)
%+|	"当前"作业(前台最后结束的作业, 或后台最后启动的作业)
%-|	最后的作业
$!|	最后的后台进程


## 关于命令
命令就是linux命令
整理几个没见过的文本处理命令：
expand, unexpand
expand命令将会把每个tab转化为一个空格. 这个命令经常用在管道中.
unexpand命令将会把每个空格转化为一个tab. 效果与expand命令相反.
cut 从文件中提取特定域
选项就是-d(字段定界符)和-f(域分隔符)


## 字体颜色
最常用的是粗体文本
```
echo -e "033[1m This is bold Text 033[0m"
tput sgr0
echo -e '\E37;44m'"033[1m String 033[0m"
```
如上，-e转义反斜杠字符。[1m 打开粗体设置，[0m关闭
\033 用于引导非常规字符序列
37为字体颜色，44位背景颜色

sgr0可以让终端设置回复正常。省略这个，终端后续输入会保持上一个设置的颜色字体

color | foreground | background
---|--- |---
black | 30 | 40
red | 31 | 41
green | 32 | 42
yellow | 33 | 43
blue | 34 | 44
magenta | 35 | 45
cyan | 36 | 46
white | 37 | 47

#### echo 命令使用的转义参数
- a	闹铃
- b	退格
- c	强制换行
- e	退出
- f	清除屏幕
- n	新行
- r	Carriage return.
- t	水平制表符
- v	垂直制表符
- \	反斜杠

#### 设置属性：
- \033[0m	关闭所有属性
- \033[1m	设置高亮
- \033[4m	下划线
- \033[5m	闪烁
- \033[7m	反显
- \033[8m	消隐
- \033[30m 至 \33[37m	前景色
- \033[40m 至 \33[47m	背景色
- \033[nA	光标上移n行
- \033[nB	光标下移n行
- \033[nC	光标右移n行
- \033[nD	光标左移n行
- \033[y;xH	设置光标位置
- \033[2J	清屏
- \033[K	清除从光标到行尾的内容
- \033[s	保存光标位置
- \033[u	恢复光标位置
- \033[?25l	隐藏光标
- \033[?25h	显示光标


#### 何时选用shell开发？
> 操作中主要在调用其他的工具并且做一些相对很小的数量，对性能没有过高要求并且代码量不超过100行时，选择shell开发。文件通常不建议使用扩展名(.sh)，文件类型由文件首行`#!/bin/bash`决定

#### 函数注释规范
- 顶层注释，备注脚本功能
- 函数注释（函数的描述，全局变量，参数，返回值）
```
#######################################
# Cleanup files from the backup dir
# Globals:
#   BACKUP_DIR
#   ORACLE_SID
# Arguments:
#   None
# Returns:
#   None
#######################################
```

## 格式规范
- 缩进一律2个空格
- 行的最大长度为80
- 管道如果一行放不下，将整个管道分割成每行一个管段
- 将`;do`和`;then`与`while`,`for`,`if`放在同一行
- 除非需要小心不带引用的扩展，否则总是引用包含变量、命令替换符、空格或shell元字符的字符串。
- 推荐引用是单词的字符串（而不是命令选项或者路径名）。
- 千万不要引用整数。
- 注意 `[[` 中模式匹配的引用规则。
- 请使用 `$@` 除非你有特殊原因需要使用 `$*` 。


## 特性及错误
- 命令替换可以使用``,最好使用括号，在嵌套命令中更方便并易于阅读
即：
```
res="`command1\`command2\``"
同：res="$(command1 "$(command2)")"
```

- 尽量使用`[[ ... ]]`而不是`[ ... ]`
因为在`[[`之间不会有路径名称扩展或单词分割发生，所以使用 [[ ... ]] 能够减少错误。而且 [[ ... ]] 允许正则表达式匹配。

- 对字符串的存在判断使用`-z`,`-n`


## 命名约定
- 函数名and变量名 使用小写字母，并用下划线分隔单词。使用双冒号 `::`分隔库
```
my_package::my_func()
```
- 常量和环境变量 全部大写，用下划线分隔，声明在文件的顶部
- 只读变量 使用 `readonly` 或者 `declare -r` 来确保变量只读。
- 使用本地变量 使用 local 声明特定功能的变量。声明和赋值应该在不同行。使用 local 来声明局部变量以确保其只在函数内部和子函数中可见
- 函数位置 将文件中所有的函数一起放在常量下面。不要在函数之间隐藏可执行代码

